name: Build and Deploy to DigitalOcean

on:
  push:
    tags:
      - "v*"

jobs:
  # make the build an sepperate action that looks at the tag
  # build:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Log in to DigitalOcean Container Registry
  #       uses: docker/login-action@v2
  #       with:
  #         registry: ${{ secrets.DOCR_REGISTRY }}
  #         username: ${{ secrets.DOCR_USERNAME }}
  #         password: ${{ secrets.DOCR_PASSWORD }}

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     # Build & Push Laravel app image
  #     - name: Build and Push Laravel Image
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: .
  #         file: ./dockerfile
  #         push: true
  #         tags: |
  #           ${{ secrets.DOCR_REGISTRY }}/statamic-app:${{ github.ref_name }}
  #           ${{ secrets.DOCR_REGISTRY }}/statamic-app:latest

  # Build & Push MinIO custom image
  # - name: Build and Push MinIO Image
  #   uses: docker/build-push-action@v5
  #   with:
  #     context: .
  #     file: ./docker/dockerfile.minio
  #     push: true
  #     tags: |
  #       ${{ secrets.DOCR_REGISTRY }}/statamic-minio:${{ github.ref_name }}
  #       ${{ secrets.DOCR_REGISTRY }}/statamic-minio:latest

  # make terraform a seperate action with if statment that looks at the tag
  # Provision infrastructure with Terraform
  terraform:
    runs-on: ubuntu-latest
    environment: production
    # needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate app.yaml
        run: |
          cat <<EOF > app.yaml
          name: statamic-app
          region: ${{ secrets.REGION }}
          services:
            - name: web
              image:
                registry_type: DOCR
                repository: ${{ secrets.DOCR_REPOSITORY }}
                tag: latest
              http_port: 8080
              instance_size_slug: basic-xxs
              instance_count: 1
              envs:
                - key: APP_ENV
                  value: "${{ secrets.APP_ENV }}"
                - key: APP_KEY
                  scope: RUN_AND_BUILD_TIME
                  value: "${{ secrets.APP_KEY }}"
                - key: DB_HOST
                  value: "${{ secrets.DB_HOST }}"
                - key: DB_DATABASE
                  value: "${{ secrets.DB_DATABASE }}"
                - key: DB_USERNAME
                  value: "${{ secrets.DB_USERNAME }}"
                - key: DB_PASSWORD
                  value: "${{ secrets.DB_PASSWORD }}"
                - key: APP_DEBUG
                  value: "${{ secrets.APP_DEBUG }}"
                - key: LOG_LEVEL
                  value: "${{ secrets.LOG_LEVEL }}"
          EOF

      - name: Print app.yaml contents
        run: cat app.yaml

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      - name: Terraform Init & Apply with remote backend
        run: |
          set -euo pipefail
          cd infra

          # Build backend.hcl from secrets (use an endpoints map so HCL is valid)
          cat > backend.hcl <<EOF
          bucket         = "${{ secrets.TF_STATE_BUCKET }}"
          key            = "${{ vars.TF_STATE_PATH }}terraform.tfstate"
          region         = "${{ secrets.TF_STATE_REGION }}"
          endpoints = {
            s3 = "${{ secrets.TF_STATE_ENDPOINT }}"
          }
          access_key     = "${{ vars.DO_SPACES_KEY }}"
          secret_key     = "${{ secrets.DO_SPACES_SECRET }}"
          skip_credentials_validation = true
          skip_metadata_api_check     = true
          skip_requesting_account_id  = true
          use_path_style = true
          EOF

          export TF_IN_AUTOMATION=1

          # Initialize Terraform non-interactively and reconfigure backend using the generated backend.hcl
          terraform init -input=false -reconfigure -backend-config=backend.hcl

          terraform apply -input=false -auto-approve \
            -var "do_token=${{ secrets.DO_TOKEN }}" \
            -var "app_key=${{ secrets.APP_KEY }}" \
            -var "app_image=${{ secrets.DOCR_REGISTRY }}/${{ vars.DOCR_IMAGE }}:latest" \
            -var "db_password=${{ secrets.DB_PASSWORD }}" \
            -var "region=${{ secrets.REGION }}" \
            -var "redis_password=${{ secrets.REDIS_PASSWORD }}" \
            -var "spaces_key=${{ secrets.SPACES_KEY }}" \
            -var "app_repository=${{ secrets.DOCR_REPOSITORY }}" \
            -var "db_connection=${{ secrets.DB_CONNECTION }}" \
            -var "db_host=${{ secrets.DB_HOST }}" \
            -var "db_port=${{ secrets.DB_PORT }}" \
            -var "db_name=${{ secrets.DB_DATABASE }}" \
            -var "db_user=${{ secrets.DB_USERNAME }}" \
            -var "app_debug=${{ vars.APP_DEBUG }}" \
            -var "spaces_bucket=${{ secrets.SPACES_BUCKET }}" \
            -var "spaces_secret=${{ secrets.SPACES_SECRET }}" | tee terraform.log

          # Export outputs as JSON and move to top-level so other jobs can pick them up as an artifact
          terraform output -json > tf_outputs.json
          mv tf_outputs.json ..

      # - name: Upload Terraform outputs
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: terraform-outputs
      #     path: tf_outputs.json

      # - name: Upload Terraform log
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: terraform-log
      #     path: infra/terraform.log
